---
title: UNIT4A：資料框處理套件`dplyr`
author: Tony Chuo, NSYSU
date: "`r Sys.time()`"
output: 
  html_document: 
    css: ../etc/style.css
    highlight: pygments
    theme: spacelab
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=F, results='hide', message=FALSE, warning=FALSE}
# Installation, setup & formatting. Do not modify this code chunk.
rm(list=ls(all=T))
knitr::opts_chunk$set(paged.print=FALSE, comment = NA)
knitr::opts_knit$set(global.par = TRUE)
par(cex=0.8); options(scipen=20, digits=4, width=90)
if(!require(pacman)) install.packages("pacman")
if(!require(dplyr)) install.packages("dplyr")
if(!require(tidyr)) install.packages("tidyr")
if(!require(ggplot2)) install.packages("ggplot2")
options(scipen=20, digits=4, width=80, tibble.print_min=4)
rmarkdown::find_pandoc(version = '2.7.3')
```


<br>
<z>學習重點</z>：使用`dplyr`套件做資料框整理
<br>

載入套件與資料
```{r message=FALSE, warning=FALSE}
pacman::p_load(dplyr,tidyr,ggplot2)
D = readRDS("data/counties.rds")
D
```
<br>

### 1. 資料轉換 
```{r}
class(D)  # 列出物件的資料結構
```
`tbl_df` 可以看成加強版的 `data_frmae`；原有資料框的操作之外，它有一些附加的功能 

🌻 <z>`glimpse`</z>  加強版的`str`
```{r}
glimpse(D)
```

🌞 `D` : 全美國3,138個郡(county)的統計資料

🌻 <z>`select()`</z>  選擇欄位(變數) 
```{r}
D %>% select(state,county,population,unemployment)
```

```{r}
D1 = D %>% select(state,county,population,unemployment)
```

🌻 <z>`arrange()`</z>  重新排列資料(rows) 
```{r}
D1 %>% arrange(population) %>% head
# D1[order(D1$population),] %>% head
```

```{r}
D1 %>% arrange(desc(population)) %>% head   # 降冪排列
# D1[order(-D1$population),] %>% head
```

<br>
❓ 請列舉這幾個功能的主要異同 `sort()`, `order()` and `arrange()`?  
```{r}
#sort() 是直接對該資料排序 例如:
CM<-c(512,2024,317)
sort(CM)#會得到 317 512 2024 的排序


#order() 是得到該順位於資料中在哪裡 如:
CM<-c(512,2024,317)
order(CM)#會得到3 1 2 最小的1位是317位在3號位 依此類推


#arrange() 是根據給定的項目對重新排列

#主要異同: sort() 跟 arrange() 會去對資料做排序，order()是回傳排序的位置
#但arrange比sort多了可以指定要依據誰排

```

<br>

🌻 <z>`filter()`</z>  篩選資料
```{r}
D1 %>% 
  filter(state == "New York", unemployment < 8) %>% 
  arrange(desc(population))
```

🌻 <z>`mutate()`</z> : 定義新欄位
```{r}
D1 %>% 
  mutate(n_unemp = unemployment*population/100) %>%
  arrange(desc(n_unemp)) %>% 
  head(4)
```

以上的這些功能用我們已經學過的R內建功能(配合索引)也都做得到，所以為什麼還要學`dplyr`呢？ 🤔 <br>

🌞 `dplyr`的好處在於:

+ 跟人類語言(英文)比較接近
+ 可以一次產生或者選擇很多個變數 
+ 也可以一次使用很多個條件做排序或者篩選
+ 很方便配合`%>%`使用，做出比較複雜或者步驟比較多的資料裝配線 

<br><br>

### 2. 資料彙總

🌻 <z>`count()`</z>  分類計算數量或加總 
```{r}
count(D)             # 總資料筆數
```

```{r}
count(D1, state)      # 各州的資料筆數 No. Counties
# table(D$state)
```

`count()` 可以說是加強版的 `table()`
```{r}
D1 %>% count(state, wt=population, sort=T)
```
With the `wt` and `sort` arguments, it can 

+ sums `population` by `state`'s
+ and sorts the results in descending order
+ and the result is returned in a tibble

in a single line of code. <br>

🌻 <z>`summarise()`</z> 資料彙總，可以一次定義很多個彙總值，
```{r}
D %>% summarise(
  totalPop = sum(population),
  avgPop = mean(population)
  )
# sum(D$population)
# mean(D$population)
```

+ 等號的右邊必須要是一個單值(算出單值的運算式).  

🌻 <z>`group_by() %>% summarise()`</z> 分類(群)彙總 
```{r}
D1 %>% group_by(state) %>% summarise(
  totalPop = sum(population),
  avgPop = mean(population)
  ) %>% 
  arrange(desc(avgPop))
```
<br>

❓ 我們之前有學過用 tapply()` 做分群運算，跟相比較 `group_by() %>% summarise()`有甚麼好處呢?  <br>
```{r}
#1. group_by() %>% summarise() 在做複雜運算的時候會看起來比較清楚明瞭
#2. group_by() %>% summarise() 可以一次就做很多彙總值
```


跟 `tapply()` 一樣，我們也可以一次 `group_by` 很多個分群變數 
```{r}
D %>% group_by(state, metro) %>% summarise(
  totalPop = sum(population),
  avgPop = mean(population)
  ) %>% 
  arrange(desc(avgPop))
```

🌷 但是 ...

+ 每一次 `summarise()` 只會自動去除<z>最後一個</z>分群變數
+ 殘留的分群變數有時可以繼續使用，有時可能會帶來麻煩
+ 不再需要的分群變數最好用 `.groups="drop"` 去除掉

<br>

🌻  <z>`top_n(x, n, wt)`</z> select the `top-n` rows by `wt` from `x`
```{r}
# select from D1 the three rows that has the largest populations 
D1 %>% top_n(n=3, wt=population)
```

```{r}
# select from each `state` the three rows that has the largest populations 
group_by(D1, state) %>% top_n(3, population)%>% head(9)
```

❓ 上面兩段程式的差別在哪裡呢？
```{r}
#第一段是整個資料集中population前3高的欄位

#第二段是先group by state的前三高population,再求該州的前三高population的row，
#最後把這些全部的前9row列出
```

<br><br>

### 3. 更靈活的語法 Select, Transmute and Rename 

`select()` 可以選擇一個<z>範圍</z>的欄位
```{r}
D %>% select(state, county, drive:work_at_home)
```

也可以用字串比對做選擇，如 `starts_with`, `ends_with` or `contains` 
```{r}
D %>% select(state, county, contains("work"))
# D %>% select(state, county, starts_with("work"))
```

也可以刪去某些欄位
```{r}
D %>% select(-contains("work")) %>% ncol
```

`names()` 列出所有欄位名稱 
```{r}
names(D1)
```

🌻 <z>`rename()`</z> 變更欄位名稱
```{r}
D1 %>% rename(unemp = unemployment) %>% head(3)
```

`select()`可以同時對多個欄位做選擇、排序和變更名稱
```{r}
D1 %>% select(state, county, unemp = unemployment, population) %>% head(3)
```

🌻 <z>`transmute()`</z>  結合`select()`和`mutate()`的功能，可以同時做欄位選擇和定義新欄位
```{r}
D %>% transmute(state, county, pop=population, fracM = men/population)
```


<br><br><hr>


