avg.Revenue = mean(s)  # 平均顧客資歷
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均毛利") + xlab("平均顧客資歷")
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(raw),            # 平均毛利
avg.Revenue = mean(r)  # 平均最近購買
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均毛利") + xlab("平均最近購買")
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(r),            # 平均最近購買
avg.Revenue = mean(s)  # 平均顧客資歷
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均毛利") + xlab("平均顧客資歷")
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(r),            # 平均最近購買
avg.Revenue = mean(s)  # 平均顧客資歷
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均最近購買") + xlab("平均顧客資歷")
knitr::include_graphics("./data/marketing_1.jpg")
knitr::include_graphics("./data/marketing/1.jpg")
knitr::include_graphics("./data/marketing/2.jpg")
knitr::include_graphics("./data/marketing/3.jpg")
knitr::include_graphics("./data/marketing/4.jpg")
knitr::include_graphics("./data/marketing/5.jpg")
knitr::include_graphics("./data/marketing/6.jpg")
# Chunk 1
# 這些程式碼設定網頁的格式，並安裝、載入一些基本的套件，請大家不要去改動<br>
rm(list=ls(all=T))
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(global.par = TRUE)
options(scipen=20, digits=4, width=80, tibble.print_min=4)
if(!require(ggthemes)) install.packages("ggthemes")
if(!require(pacman)) install.packages("pacman")
# Chunk 2
head(faithful)          # load data and
D = faithful$eruptions  # copy it to a short name
# Chunk 3
##### 先畫一個圖框
par(cex=0.7)
plot(0,0,xlim=c(1.5,5.25),ylim=c(0,1.1),xlab="噴發時間(分鐘)",
ylab="密度 or (累計)機率", main="分布、機率與密度")
abline(h=1, col='lightgray', lwd=0.25, lty=2)
##### 數值標記
# Empirical Rug PDF, 實證(數值標記)機率密度函數
rug(D)
# Empirical CDF, 實證(數值標記)累計機率密度函數
plot(ecdf(D), cex=0, verticals=T, lwd=2, col='darkgray', add=T)
##### Histogram PDF 直方圖機率密度函數
Bins = 20                               # no. bins
bx = seq(min(D), max(D), length=Bins+1) # break sequence
hist(D, col="#B3FFFF7F", border="white",
freq=F, breaks=bx, add=T)
abline(h=0, col='lightgray', lwd=0.25)
# Histogram CDF
adj = (bx[2] - bx[1])/2
steps = stepfun(bx-adj, c(0, sapply(bx, function(b) mean(D <= b))))
plot(steps, cex=0, col='#33CC337F', lwd=3, lty=1, add=T)
##### Smooth PDF 平滑機率密度函數
Adjust = 0.5                       # set bandwidth
DEN = density(D, adjust = Adjust)  # create density function
lines(DEN, col='gold', lwd=3)
# Smooth CDF 畫出累計機率密度函數
PDF = approxfun(DEN$x, DEN$y, yleft=0, yright=0)
x = seq(1,6,0.1)
y = sapply(x, function(i) integrate(PDF, -Inf, i)$value)
lines(x, y, col='red', lwd=3, lty=2)
##### 標示範圍[x1, x2]
x1 = 3.8; x2 = 4.8
# rect(x1,-0.1,x2,1.2,col= rgb(0,1,0,alpha=0.2),border=NA)
x = seq(x1, x2, length=100)
polygon(c(x, x2, x1),  c(PDF(x), 0, 0), col="#FF99003F", border=NA)
# Chunk 4
# Calculate Probability 算出範圍[x1, x2]的機率
(integrate(PDF, x1, x2)$value)
# Chunk 5
pacman::p_load(dplyr, ggplot2)
x1 = seq(0,5,0.1)
p = sapply(x1, function(x) (integrate(PDF, x, x+1)$value))
data.frame(start=x1, stop=1+x1, p) %>% top_n(1, p)
# Chunk 6
x = seq(1,6,1/6)
cx = sapply(x, function(i) integrate(PDF, -Inf, i)$value)
df = data.frame(
start = x - 1/6, stop = x,
prob=cx -lag(cx)
) %>%
mutate(payoff = 100*prob - 5)
bets = df %>% filter(payoff > 0) %>% arrange(start)
bets
# Chunk 7
nrow(bets)
sum(bets$payoff)
# Chunk 8
df = df %>% arrange(desc(payoff)) %>% mutate(
n_bets = row_number(),
c_invest = n_bets * 5,
c_payoff = cumsum(payoff),
c_ROI = c_payoff/c_invest
) %>% round(3)
head(df,20) %>% round(3)
# Chunk 9
ggplot(df[1:20,], aes(c_ROI, c_payoff, color=c_invest)) +
geom_point(size=3) +
geom_text(aes(label=n_bets), color='black', nudge_y=0.6, size=2.5) +
scale_color_gradientn(colors=c('seagreen','gold','gold','orange','tomato','red')) +
labs(title="策略空間",color="投資金額",y="預期報償",x="預期投報率")
x = seq(1,6,1/6)
cx = sapply(x, function(i) integrate(PDF, -Inf, i)$value)
df = data.frame(
start = x - 1/6, stop = x,
prob=cx -lag(cx)
) %>%
mutate(payoff = 100*prob - 5)
bets = df %>% filter(payoff > 0) %>% arrange(start)
bets
nrow(bets)
sum(bets$payoff)
df = df %>% arrange(desc(payoff)) %>% mutate(
n_bets = row_number(),
c_invest = n_bets * 5,
c_payoff = cumsum(payoff),
c_ROI = c_payoff/c_invest
) %>% round(3)
head(df,20) %>% round(3)
result <- A0 %>%
group_by(area, age) %>%
summarize(total_customers = n())%>%
arrange(desc(total_customers))
pacman::p_load(vcd, magrittr, readr, caTools, ggplot2, dplyr, plotly)
load("data/tf0.rdata")
sapply(list(cust=A0,tid=X0,items=Z0), nrow)
par(mfrow=c(1,2),cex=0.7)
table(A0$age) %>% barplot(las=2,main="Age Groups")
table(A0$area) %>% barplot(las=2,main="Areas")
MOSA = function(formula, data) mosaic(formula, data, shade=T,
margins=c(0,1,0,0), labeling_args = list(rot_labels=c(90,0,0,0)),
gp_labels=gpar(fontsize=9), legend_args=list(fontsize=9),
gp_text=gpar(fontsize=7),labeling=labeling_residuals)
MOSA(~age+area, A0)
result <- A0 %>%
group_by(area, age) %>%
summarize(total_customers = n())%>%
arrange(desc(total_customers))
# 输出结果
print(result,row=20)
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(f),            # 平均購買次數
avg.Revenue = sum(f*m)/sum(f)  # 平均客單價
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均購買次數") + xlab("平均客單價")
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(r),            # 平均最近購買
avg.Revenue = mean(s)  # 平均顧客資歷
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均最近購買") + xlab("平均顧客資歷")
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(raw),            # 平均毛利
avg.Revenue = mean(s)  # 平均顧客資歷
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均毛利") + xlab("平均顧客資歷")
A0 %>% filter(age!="a99") %>%    # 濾掉沒有年齡資料的顧客('a99')
group_by(area) %>% summarise(
Group.Size = n(),              # 族群人數
avg.Freq = mean(raw),            # 平均毛利
avg.Revenue = mean(r)  # 平均最近購買
) %>%
ggplot(aes(y=avg.Freq, x=avg.Revenue)) +
geom_point(aes(col=area, size=Group.Size), alpha=0.5) +
geom_text(aes(label=area)) +
scale_size(range=c(5,25)) +
theme_bw() + theme(legend.position="none") +
ggtitle("地理區隔特徵 (泡泡大小:族群人數)") +
ylab("平均毛利") + xlab("平均最近購買")
result <- A0 %>%
group_by(area, age) %>%
summarize(total_customers = n())%>%
arrange(desc(total_customers))
# 输出结果
options(dplyr.print_max = 1e9)
print(result)
result <- A0 %>%
group_by(area, age) %>%
summarize(total_customers = n())%>%
arrange(desc(total_customers))
# 输出结果
options(dplyr.print_max = 100)
print(result)
knitr::include_graphics("./data/marketing/new1.jpg")
knitr::include_graphics("./data/marketing/new2.jpg")
knitr::include_graphics("./data/marketing/new3.jpg")
# Formating Codes.  Do not change the codes in this chunk.<br>
rm(list=ls(all=T))
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(global.par = TRUE)
par(cex=0.8)
options(scipen=20, digits=5, width=80)
if(!require(pacman)) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, car, vcd, GGally, mvtnorm)
W = read.csv('data/wholesales.csv')
W$Channel = factor( paste0("Ch",W$Channel) )
W$Region = factor( paste0("Reg",W$Region) )
W[3:8] = lapply(W[3:8], log, base=10)
summary(W)
par(cex=0.7, mar=c(4,4,2,2))
plot(W$Milk, W$Grocery)
ggplot(W, aes(x=Milk, y=Grocery)) +
geom_point(alpha=0.3) +
geom_smooth(method="lm")
cor(W$Milk, W$Grocery)
cor.test(W$Milk, W$Grocery)
par(cex=0.7, mar=c(1,1,1,1), mfrow=c(3,3))
for(r in seq(-1,1,0.25)) {
mu = c(0,0)
sigma = matrix(c(1,r,r,1),nrow=2)   # covariance matrix
rmvnorm(500, mu, sigma) %>% plot(col='gray')
text(0,0,r,cex=3,col='blue',font=2)
}
cor(W[,3:8]) %>% round(3)
car::scatterplotMatrix(W[,3:8])
table(W$Channel, W$Region) %>% chisq.test()
library(vcd)
structable(Channel ~ Region, W) %>%
mosaic(shade=T, labeling=labeling_residuals)
haireye <- margin.table(HairEyeColor, 1:2)
haireye
(mpHair = rowSums(haireye)/sum(haireye)) # marginal prob.
(mpEye = colSums(haireye)/sum(haireye)) # marginal prob.
(expProb = mpHair %o% mpEye)
sum(expProb)
(expVal = expProb * sum(haireye))
(s.res = (haireye - expVal) / sqrt(expVal))
mosaic(haireye, shade=T, labeling=labeling_residuals)
( expected = independence_table(haireye) )
(rowSums(haireye) %o% colSums(haireye)) / sum(haireye)
( residuals = haireye - expected )
( std.residuals = residuals / sqrt(expected)  )
library(GGally)
ggpairs(iris, aes(colour = Species, alpha=0.4),
lower=list(combo = wrap("facethist", binwidth = 0.2)))
par(cex=0.8, mar=c(2,3,1,1), mfrow=c(1,1))
table(W$Channel) %>% barplot
par(cex=0.8, mar=c(4,3,1,1))
hist(W$Fresh)
structable(Channel ~ Region, W) %>%
mosaic(shade=T, labeling=labeling_residuals)
tapply(W$Milk, W$Region, sum)
tapply(W$Milk, list(W$Channel, W$Region), mean)
tapply(W$Milk, list(W$Channel, W$Region), sum)
xtabs(Milk ~ Channel + Region, data=W)
ggplot(W, aes(x=log(Milk))) +
geom_histogram(aes(fill=Region), alpha=0.5, bins=20) +
facet_grid(Channel~Region) +
labs(title="Distribtion of Sales of Milk")
ggplot(W, aes(x=log(Milk))) +
geom_density(aes(fill=Region), alpha=0.5) +  # compare the density of Region
facet_grid(~Channel) +                       # by Channel
labs(title="Density of Sales of Milk")
ggplot(W, aes(x=log(Milk))) +
geom_density(aes(fill=Channel), alpha=0.5) +  # compare the density of Channel
facet_grid(~Region) +                         # by Region
labs(title="Density of Sales of Milk")
ggplot(W, aes(x=log(Milk), y=log(Fresh))) +
geom_point() +
stat_smooth(method="lm",se=F)
ggplot(W, aes(x=log(Milk), y=log(Fresh))) +
geom_point() +
stat_smooth(method="lm", se=F) +
facet_grid(~Region)
ggplot(W, aes(x=log(Milk), y=log(Fresh))) +
geom_point() +
stat_smooth(method="lm", se=F, col='red') +
facet_grid(Channel~Region)
# Formating Codes.  Do not change the codes in this chunk !!
rm(list=ls(all=T))
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(global.par = TRUE)
par(cex=0.8)
options(scipen=20, digits=5, width=80)
if(!require(pacman)) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, corrplot)
D = read.csv('data/climate_change.csv')
head(D)
TR = subset(D, Year <= 2006)  # Train Data
TS = subset(D, Year > 2006)   # Test Data
m1 = lm(Temp~MEI+CO2+CH4+N2O+CFC.11+CFC.12+TSI+Aerosols,TR)
options(digits=4, scipen=10)
summary(m1)
vx = c(3:5,7); cx = summary(m1)$coef
par(cex=0.8)
plot(0,0,xlim=c(-0.04,0.02),ylim=c(0,800),pch=20,
xlab="coefficients: the estimated value of b's",
ylab='probability density',
main='Probability Density Function of Coefficients')
abline(h=seq(0,800,100),v=seq(-0.04,0.03,0.0025),col='lightgray',lty=3)
for(i in vx) curve(dnorm(x,cx[i,1],cx[i,2]),add=T,col=i,lwd=2,n=1000)
abline(v=0,col='red')
legend("topleft",col=vx,lwd=2,legend=paste0(
"b",vx," ( ",rownames(cx)[vx]," )", c("**","","。","***") ) )
summary(m1)$coef[vx,]
cor(TR[3:10]) %>% round(2)
cor(TR[3:10]) %>% corrplot.mixed(tl.cex=0.7, tl.col='black')
m2 = lm(Temp~MEI+N2O+TSI+Aerosols,TR)  # 手動挑選自變數
summary(m2)
m3 = step(m1)   # 自動挑選自變數
summary(m3)
pred =  predict(m3)                     # 使用訓練資料做預測
SSE = sum((pred - TR$Temp)^2)           # SSE.train
SST = sum((mean(TR$Temp) - TR$Temp)^2)  # SST.train
R2 = 1 - SSE/SST                        # R2.train
RMSE = sqrt(SSE/nrow(TR))               # RMSE.train
c(SSE, SST, R2, RMSE)
pred =  predict(m3, TS)                 # 使用測試資料做預測
SSE = sum((pred - TS$Temp)^2)           # SSE.test
SST = sum((mean(TR$Temp) - TS$Temp)^2)  # SST.test
R2 = 1 - SSE/SST                        # R2.test
RMSE = sqrt(SSE/nrow(TS))               # RMSE.test
c(SSE, SST, R2, RMSE)
# Formating Codes.  Do not change the codes in this chunk.<br>
rm(list=ls(all=T))
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(global.par = TRUE)
par(cex=0.8)
options(scipen=20, digits=5, width=80)
if(!require(pacman)) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, plotly, ggpubr)
W = read.csv('data/wholesales.csv')
W$Channel = factor( paste0("Ch",W$Channel) )
W$Region = factor( paste0("Reg",W$Region) )
W[3:8] = lapply(W[3:8], log, base=10)
md = lm(Milk ~ Grocery, W)
summary(md)
yhat = predict(md,W)
y = W$Milk                # 目標變數
x = W$Grocery             # 解釋變數
b0 = md$coef[1]           # 捷距
b1 = md$coef[2]           # 斜率
yhat = b0 + b1 * x        # 預測值
er = y - yhat             # 殘差 (Residual)
# range(yhat - md$fitted.values)
# range(er - md$residuals)
par(cex=0.8, mar=c(4,4,1,1))
plot(W$Grocery, W$Milk, pch=20, col="#80808080")
abline(b0, b1, col='red')
ggplot(aes(Grocery, Milk), data=W) +
geom_point(alpha=0.4, size=0.8) +
geom_smooth(method="lm", level=0.95, lwd=0.2) +
theme_bw() -> p
ggplotly(p)
new_data = tibble(Grocery = seq(1,5,0.5))
new_data
conf = predict(md, new_data, interval="confidence"); conf
pred = predict(md, new_data, interval="prediction"); pred
df = cbind(new_data,conf,pred[,-1])
names(df) = c("x","yhat","c.lwr","c.upr","p.lwr","p.upr")
df
ggplot(df, aes(x)) +
geom_point(aes(y=yhat),col='red',size=2) +
geom_line(aes(y=yhat),col='red') +
geom_line(aes(y=c.lwr),col='orange') +
geom_line(aes(y=c.upr),col='orange') +
geom_line(aes(y=p.lwr),col='magenta',linetype='dashed') +
geom_line(aes(y=p.upr),col='magenta',linetype='dashed') +
geom_point(data=W, aes(x=Grocery, y=Milk), size=0.8, alpha=0.5) +
xlim(1,5) + ylim(1,5) + theme_bw()
summary(md)
curve(dnorm(x, 0.7352, 0.0301), -0.1, 1, n=400, xlab=bquote(italic(b[1])),
main=bquote("The Distribution of Random Variable: " ~ italic(b[1])))
abline(v=qnorm(c(0.025, 0.975),0.7352, 0.0301), col="red")
# Formating Codes.  Do not change the codes in this chunk !!
rm(list=ls(all=T))
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(global.par = TRUE)
par(cex=0.8)
options(scipen=20, digits=5, width=80)
if(!require(pacman)) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, corrplot)
D = read.csv('data/climate_change.csv')
head(D)
TR = subset(D, Year <= 2006)  # Train Data
TS = subset(D, Year > 2006)   # Test Data
m1 = lm(Temp~MEI+CO2+CH4+N2O+CFC.11+CFC.12+TSI+Aerosols,TR)
options(digits=4, scipen=10)
summary(m1)
vx = c(3:5,7); cx = summary(m1)$coef
par(cex=0.8)
plot(0,0,xlim=c(-0.04,0.02),ylim=c(0,800),pch=20,
xlab="coefficients: the estimated value of b's",
ylab='probability density',
main='Probability Density Function of Coefficients')
abline(h=seq(0,800,100),v=seq(-0.04,0.03,0.0025),col='lightgray',lty=3)
for(i in vx) curve(dnorm(x,cx[i,1],cx[i,2]),add=T,col=i,lwd=2,n=1000)
abline(v=0,col='red')
legend("topleft",col=vx,lwd=2,legend=paste0(
"b",vx," ( ",rownames(cx)[vx]," )", c("**","","。","***") ) )
summary(m1)$coef[vx,]
cor(TR[3:10]) %>% round(2)
cor(TR[3:10]) %>% corrplot.mixed(tl.cex=0.7, tl.col='black')
m2 = lm(Temp~MEI+N2O+TSI+Aerosols,TR)  # 手動挑選自變數
summary(m2)
m3 = step(m1)   # 自動挑選自變數
summary(m3)
pred =  predict(m3)                     # 使用訓練資料做預測
SSE = sum((pred - TR$Temp)^2)           # SSE.train
SST = sum((mean(TR$Temp) - TR$Temp)^2)  # SST.train
R2 = 1 - SSE/SST                        # R2.train
RMSE = sqrt(SSE/nrow(TR))               # RMSE.train
c(SSE, SST, R2, RMSE)
pred =  predict(m3, TS)                 # 使用測試資料做預測
SSE = sum((pred - TS$Temp)^2)           # SSE.test
SST = sum((mean(TR$Temp) - TS$Temp)^2)  # SST.test
R2 = 1 - SSE/SST                        # R2.test
RMSE = sqrt(SSE/nrow(TS))               # RMSE.test
c(SSE, SST, R2, RMSE)
# Formating Codes.  Do not change the codes in this chunk !!
rm(list=ls(all=T))
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(global.par = TRUE)
par(cex=0.8)
options(scipen=20, digits=5, width=80)
if(!require(pacman)) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, corrplot)
D = read.csv('data/climate_change.csv')
head(D)
TR = subset(D, Year <= 2006)  # Train Data
TS = subset(D, Year > 2006)   # Test Data
m1 = lm(Temp~MEI+CO2+CH4+N2O+CFC.11+CFC.12+TSI+Aerosols,TR)
options(digits=4, scipen=10)
summary(m1)
vx = c(3:5,7); cx = summary(m1)$coef
par(cex=0.8)
plot(0,0,xlim=c(-0.04,0.02),ylim=c(0,800),pch=20,
xlab="coefficients: the estimated value of b's",
ylab='probability density',
main='Probability Density Function of Coefficients')
abline(h=seq(0,800,100),v=seq(-0.04,0.03,0.0025),col='lightgray',lty=3)
for(i in vx) curve(dnorm(x,cx[i,1],cx[i,2]),add=T,col=i,lwd=2,n=1000)
abline(v=0,col='red')
legend("topleft",col=vx,lwd=2,legend=paste0(
"b",vx," ( ",rownames(cx)[vx]," )", c("**","","。","***") ) )
summary(m1)$coef[vx,]
cor(TR[3:10]) %>% round(2)
cor(TR[3:10]) %>% corrplot.mixed(tl.cex=0.7, tl.col='black')
m2 = lm(Temp~MEI+N2O+TSI+Aerosols,TR)  # 手動挑選自變數
summary(m2)
m3 = step(m1)   # 自動挑選自變數
summary(m3)
pred =  predict(m3)                     # 使用訓練資料做預測
SSE = sum((pred - TR$Temp)^2)           # SSE.train
SST = sum((mean(TR$Temp) - TR$Temp)^2)  # SST.train
R2 = 1 - SSE/SST                        # R2.train
RMSE = sqrt(SSE/nrow(TR))               # RMSE.train
c(SSE, SST, R2, RMSE)
pred =  predict(m3, TS)                 # 使用測試資料做預測
SSE = sum((pred - TS$Temp)^2)           # SSE.test
SST = sum((mean(TR$Temp) - TS$Temp)^2)  # SST.test
R2 = 1 - SSE/SST                        # R2.test
RMSE = sqrt(SSE/nrow(TS))               # RMSE.test
c(SSE, SST, R2, RMSE)
